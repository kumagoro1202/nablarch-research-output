---
name: framework-mcp-server-planner
description: 特定のフレームワーク（Nablarch, Spring, Rails, Django, Laravel等）向けのMCPサーバー構築計画を調査・策定する。「○○フレームワーク用のMCPサーバーを設計したい」「AIコーディングツールで○○の正確なコードを生成したい」といった要求に対し、MCP仕様調査、フレームワーク分析、Tools/Resources/Prompts設計、アーキテクチャ設計、ロードマップ策定、リスク評価までを一貫して行い、実装可能な構築計画書を出力する。
---

# Framework MCP Server Planner

## Overview

特定のフレームワークやライブラリに特化したMCP（Model Context Protocol）サーバーの構築計画を調査・策定するスキル。

MCPサーバーを構築することで、AIコーディングツール（Claude Code, Copilot, Cursor等）が対象フレームワークの正確なコードを生成できるようになる。このスキルは、そのMCPサーバーの「設計・計画フェーズ」を体系的に実行するための手順書である。

**このスキルが生み出すもの**: 対象フレームワーク向けMCPサーバーの包括的な構築計画書（Markdownレポート）

## When to Use

以下の状況・キーワードでこのスキルを使用する：

- 「○○フレームワーク用のMCPサーバーを作りたい/設計したい」
- 「AIに○○のコードを正確に書かせたい」
- 「○○のAPI情報をAIツールに提供するMCPサーバーが欲しい」
- 「○○フレームワークのMCPサーバー構築計画を策定してほしい」
- 「○○の開発効率をMCPで向上させたい」
- 特定フレームワーク/ライブラリのAI対応を検討する際

**対象フレームワーク例**: Nablarch, Spring Boot, Ruby on Rails, Django, Laravel, Express.js, Next.js, Flutter, .NET, Phoenix, FastAPI 等

## Instructions

### STEP 1: MCP最新仕様の調査

MCP仕様は進化が速いため、必ず最新情報をWeb検索で確認する。

#### 1.1 公式情報の確認

以下のURLから最新仕様を取得する：

| 情報源 | URL | 確認事項 |
|---|---|---|
| MCP公式サイト | https://modelcontextprotocol.io/ | プロトコル概要、最新ニュース |
| MCP仕様書 | https://modelcontextprotocol.io/specification/ | プロトコルバージョン、変更点 |
| MCPアーキテクチャ | https://modelcontextprotocol.io/docs/concepts/architecture | Host/Client/Server構造 |
| サーバーコンセプト | https://modelcontextprotocol.io/docs/learn/server-concepts | Tools/Resources/Prompts詳細 |
| サーバー構築ガイド | https://modelcontextprotocol.io/docs/develop/build-server | 各言語の実装例 |

#### 1.2 SDK情報の確認

対象フレームワークの言語に応じたSDKを確認する：

| 言語 | SDK | 備考 |
|---|---|---|
| Java/Kotlin | [MCP Java SDK](https://github.com/modelcontextprotocol/java-sdk) | Spring AI共同メンテナンス |
| Python | [MCP Python SDK](https://github.com/modelcontextprotocol/python-sdk) | FastMCPで簡易実装可能 |
| TypeScript | [MCP TypeScript SDK](https://github.com/modelcontextprotocol/typescript-sdk) | Node.jsベース |
| C# | [MCP C# SDK](https://github.com/modelcontextprotocol/csharp-sdk) | Microsoft共同メンテナンス |
| Go | [MCP Go SDK](https://github.com/modelcontextprotocol/go-sdk) | Google共同メンテナンス |
| Kotlin | [MCP Kotlin SDK](https://github.com/modelcontextprotocol/kotlin-sdk) | JetBrains共同メンテナンス |
| Rust | [rmcp](https://crates.io/crates/rmcp) | コミュニティメンテナンス |

#### 1.3 確認すべきポイント

- [ ] 最新のプロトコルバージョン
- [ ] 対応SDKの最新バージョンと安定性
- [ ] 新しく追加されたプリミティブ（Tasks等の実験的機能）
- [ ] トランスポート層の選択肢（STDIO, Streamable HTTP）
- [ ] 認証・認可の仕組み（OAuth 2.0対応状況）
- [ ] 既存のリファレンスサーバー実装（https://github.com/modelcontextprotocol/servers）

#### 1.4 記録テンプレート

```markdown
### MCP仕様調査結果
- **プロトコルバージョン**: YYYY-MM-DD
- **対応SDK**: {言語} SDK v{バージョン}
- **トランスポート**: STDIO / Streamable HTTP
- **プリミティブ**: Tools, Resources, Prompts [, Tasks (実験的)]
- **認証**: OAuth 2.0 / Bearer Token / なし
- **変更点**: {前回調査からの差分}
```

---

### STEP 2: 対象フレームワークの特性分析

#### 2.1 基本情報の収集

以下の観点で対象フレームワークを調査する：

| 調査項目 | 確認先 | 記録内容 |
|---|---|---|
| 公式サイト | フレームワーク公式URL | URL、概要 |
| GitHub | リポジトリ | Star数、最終更新、リポジトリ構成 |
| ドキュメント | 公式ドキュメント | 構造、網羅性、言語 |
| 言語・ランタイム | 公式情報 | 対応バージョン、要件 |
| ライセンス | LICENSE | OSS利用可否 |
| バージョン | リリースノート | 最新バージョン、LTS |
| エコシステム | プラグイン/アダプタ | 関連ツール・ライブラリ |

#### 2.2 アーキテクチャ分析

フレームワークの**独自性**を特定する。これがMCPサーバーの差別化ポイントになる。

分析すべき項目：

1. **コアアーキテクチャパターン**
   - リクエスト処理モデル（パイプライン/ミドルウェア/ハンドラキュー等）
   - DI/IoC コンテナの仕組み
   - ルーティング方式

2. **設定・構成の仕組み**
   - 設定ファイル形式（XML/YAML/アノテーション/Convention）
   - プロジェクト構造の規約
   - ビルドシステム

3. **対応アプリケーション種別**
   - Web / API / バッチ / メッセージング / etc.

4. **独自ライブラリ・機能**
   - DB アクセス
   - テスティングフレームワーク
   - セキュリティ機能
   - バリデーション

5. **開発標準・ベストプラクティス**
   - 公式が推奨するパターン
   - アンチパターン
   - コーディング規約

6. **関連エコシステム**
   - 移行ツール（例: Xenlon for Nablarch）
   - IDE統合
   - CI/CDツール

#### 2.3 分析テンプレート

```markdown
### フレームワーク特性分析

#### 基本情報
- **名称**: {フレームワーク名}
- **開発元**: {組織名}
- **言語**: {プログラミング言語}
- **最新バージョン**: {バージョン}
- **ライセンス**: {ライセンス}

#### コアアーキテクチャ
- **処理モデル**: {パイプライン/ミドルウェア/etc}
- **設定方式**: {XML/YAML/アノテーション/Convention}
- **特記事項**: {独自の設計思想}

#### 独自の強み（MCP差別化ポイント）
1. {強み1}
2. {強み2}
3. {強み3}

#### 関連エコシステム
- {関連ツール/サービス}
```

---

### STEP 3: Tools / Resources / Prompts の設計

MCPサーバーの3つのプリミティブを設計する。対象フレームワークの特性に応じて内容を決定する。

#### 3.1 Tools の設計方針

Toolsは**AIが能動的に呼び出す関数**。以下のカテゴリで検討する：

| カテゴリ | 例 | 設計指針 |
|---|---|---|
| **コード生成** | コントローラ、モデル、設定ファイルの生成 | フレームワークの規約に100%準拠した出力 |
| **検証** | 設定ファイルの妥当性チェック、依存関係検証 | 公式ドキュメントの制約に基づく |
| **検索** | API検索、パターン検索 | ドキュメント・Javadocからの情報検索 |
| **分析** | 既存コードの分析、移行分析 | フレームワーク固有のパターン認識 |
| **変換** | 設定形式変換、バージョン移行 | 破壊的変更への対応支援 |

**Tool設計チェックリスト**:
- [ ] 入力パラメータは明確か（JSON Schemaで定義可能か）
- [ ] 出力は構造化されているか
- [ ] エラーケースを想定しているか
- [ ] フレームワーク固有の制約を反映しているか
- [ ] 汎用ツール（grep等）では代替できない独自価値があるか

#### 3.2 Resources の設計方針

Resourcesは**読み取り専用のデータソース**。以下のカテゴリで検討する：

| カテゴリ | URI パターン例 | 内容 |
|---|---|---|
| **API仕様** | `{fw}://api/{module}/{class}` | Javadoc/APIリファレンス |
| **設計パターン** | `{fw}://pattern/{name}` | 公式推奨パターン |
| **アンチパターン** | `{fw}://antipattern/{name}` | 避けるべきパターン |
| **設定テンプレート** | `{fw}://config/{type}` | 標準設定の雛形 |
| **ガイド** | `{fw}://guide/{topic}` | チュートリアル・ガイド |
| **サンプルコード** | `{fw}://example/{type}` | 動作する実装例 |
| **バージョン情報** | `{fw}://version` | 最新バージョン・互換性情報 |

**Resource設計チェックリスト**:
- [ ] URIスキームは直感的か
- [ ] 固定リソースとテンプレートリソースを適切に使い分けているか
- [ ] MIME typeは正しいか
- [ ] データの更新頻度は考慮されているか
- [ ] 情報の粒度は適切か（粗すぎず細かすぎず）

#### 3.3 Prompts の設計方針

Promptsは**ユーザーが明示的に呼び出す再利用可能テンプレート**。以下のカテゴリで検討する：

| カテゴリ | 例 | パラメータ |
|---|---|---|
| **プロジェクト初期化** | 新規アプリ作成ガイド | プロジェクト名、DB種別、機能 |
| **機能追加** | CRUDエンドポイント追加 | エンティティ名、フィールド定義 |
| **コードレビュー** | フレームワーク準拠レビュー | ソースコード、レビュー観点 |
| **トラブルシューティング** | エラー診断・解決支援 | エラー情報、環境 |
| **移行** | バージョン移行/他FWからの移行 | 移行元情報、移行要件 |

**Prompt設計チェックリスト**:
- [ ] パラメータは必須/任意を明確に分けているか
- [ ] テンプレートは具体的な手順を含んでいるか
- [ ] Resources/Toolsと連携するよう設計されているか
- [ ] ユーザーが選択しやすい粒度か

---

### STEP 4: アーキテクチャ設計

#### 4.1 実装言語の選定

基本方針: **対象フレームワークと同じ言語でMCPサーバーを実装する**

| 対象FW言語 | MCPサーバー実装 | 理由 |
|---|---|---|
| Java | Java (MCP Java SDK + Spring Boot) | SDK成熟度高、Spring AI連携 |
| Python | Python (MCP Python SDK + FastMCP) | 最も簡単に実装可能 |
| TypeScript/JS | TypeScript (MCP TS SDK) | Node.jsエコシステム活用 |
| Ruby | TypeScript or Python | Ruby SDK未公式のため代替 |
| Go | Go (MCP Go SDK) | Google共同メンテナンス |
| C# | C# (MCP C# SDK) | Microsoft共同メンテナンス |

例外: 対象FWの言語に公式SDKがない場合は、TypeScript or Pythonを推奨（SDKが最も成熟）

#### 4.2 トランスポート設計

| 用途 | トランスポート | 適用場面 |
|---|---|---|
| ローカル開発 | STDIO | 個人開発者、Claude Desktop/Code連携 |
| チーム共有 | Streamable HTTP | 組織内共有、複数クライアント接続 |
| 両対応 | STDIO + HTTP | 最も汎用的（推奨） |

#### 4.3 知識ベース設計

MCPサーバーが提供する知識の管理方式を決定する：

| 方式 | 適用条件 | メリット | デメリット |
|---|---|---|---|
| **静的埋め込み** | ドキュメント量が少ない | 依存最小、高速 | 更新にビルド必要 |
| **全文検索インデックス** | ドキュメント量が多い | 柔軟な検索 | インデックス構築コスト |
| **外部DB連携** | 大規模・動的データ | スケーラブル | 複雑性増大 |
| **ハイブリッド** | 中〜大規模 | バランス良い | 設計の複雑さ |

#### 4.4 アーキテクチャ図テンプレート

```
┌──────────────────────────────────────────────┐
│           AI コーディングツール                  │
│  ┌────────────────────────────────────────┐  │
│  │              MCP Client                │  │
│  └──────────────────┬─────────────────────┘  │
└─────────────────────┼────────────────────────┘
                      │ JSON-RPC 2.0
                      │ ({トランスポート})
┌─────────────────────▼────────────────────────┐
│          {フレームワーク名} MCP Server          │
│                                               │
│  ┌────────┐  ┌──────────┐  ┌────────┐        │
│  │ Tools  │  │ Resources│  │ Prompts│        │
│  └───┬────┘  └────┬─────┘  └───┬────┘        │
│      │            │            │              │
│  ┌───▼────────────▼────────────▼───────────┐  │
│  │        Knowledge Base                   │  │
│  │  {対象FW固有の知識コンポーネント}          │  │
│  └─────────────────────────────────────────┘  │
└───────────────────────────────────────────────┘
```

---

### STEP 5: ロードマップ策定

以下の4フェーズを基準に、対象フレームワークの規模と要件に応じてカスタマイズする。

#### Phase 1: 基盤構築（MVP）

**目標**: 最小限の動作するMCPサーバー

**含めるべき要素**:
- プロジェクトスケルトン（SDK + ビルドシステム）
- STDIOトランスポート
- 基本的なResources（API仕様、主要ドキュメント）
- 基本的なTools（API検索、設定検証）
- MCP Inspectorでの動作検証

**完了基準**:
- Claude Desktop / Claude Codeから接続して動作する
- 基本的な質問に対して正確な回答を返す

#### Phase 2: コード生成機能

**目標**: AIによる対象FWコード生成の精度向上

**含めるべき要素**:
- コード生成Tools一式
- テンプレートシステム
- 設計パターン/アンチパターンResources
- 主要Prompts（プロジェクト初期化、機能追加）

**完了基準**:
- フレームワーク規約に準拠したコードを生成できる
- 生成コードがビルド・テスト通過する

#### Phase 3: 高度化・リモート展開

**目標**: チーム利用とエコシステム連携

**含めるべき要素**:
- Streamable HTTPトランスポート
- 認証・認可
- エコシステムツール連携（移行ツール等）
- Docker/コンテナ対応

**完了基準**:
- 複数ユーザーが同時接続して利用できる
- エコシステムツールと連携動作する

#### Phase 4: エコシステム拡張

**目標**: 開発ライフサイクル全体カバー

**含めるべき要素**:
- IDE統合
- プロジェクト分析機能
- バージョン自動追従
- コミュニティプラグインシステム

**完了基準**:
- 開発者の日常的なワークフローに統合される

---

### STEP 6: 実現可能性評価とリスク分析

#### 6.1 実現可能性評価フレームワーク

以下の観点で ◎/○/△/× の4段階評価を行う：

**技術的実現可能性**:

| 評価項目 | 確認事項 |
|---|---|
| MCP SDK成熟度 | 対応言語のSDKバージョン、安定性、メンテナンス体制 |
| FW情報公開度 | ドキュメント/ソースコードのOSS公開状況 |
| 技術スタック整合 | FWの言語とMCP SDKの言語の一致度 |
| 先行事例 | 類似のMCPサーバー実装の有無 |
| エコシステム連携 | 関連ツールとの統合難易度 |

**ビジネス的実現可能性**:

| 評価項目 | 確認事項 |
|---|---|
| 市場ニーズ | 対象FWのユーザー規模、AI支援開発の需要 |
| 差別化 | 既存の代替手段との比較優位性 |
| 戦略整合 | 組織の事業戦略との合致度 |
| 導入障壁 | 利用開始までのハードル |

#### 6.2 リスク分析フレームワーク

3カテゴリ × 影響度/発生確率 のマトリクスで分析する：

**技術リスク**:
- MCP仕様の破壊的変更
- FWバージョンアップ追従
- コード生成の品質問題
- パフォーマンス劣化
- エコシステムツールの非公開性

**ビジネスリスク**:
- MCP普及の遅延
- 競合の出現
- AIツール依存
- 知的財産リスク

**セキュリティリスク**:
- プロンプトインジェクション
- 機密情報漏洩
- 不正なツール実行

各リスクに対して「対策」を必ず記載する。

---

### STEP 7: レポート出力

以下の構成でレポートを作成する：

```markdown
# {フレームワーク名} MCPサーバー構築計画

> **作成日**: YYYY-MM-DD

## 1. 現状調査結果
### 1.1 MCP仕様のまとめ
### 1.2 {フレームワーク名}の特性分析
### 1.3 関連エコシステムとの関係性

## 2. 具体的な実装計画
### 2.1 アーキテクチャ設計
### 2.2 技術スタック
### 2.3 公開リソース一覧（Tools/Resources/Prompts）

## 3. 段階的な構築ロードマップ

## 4. 実現可能性の評価

## 5. リスクと対策

## 6. 参考資料
```

## Examples

### 入力例

```
「Nablarchフレームワーク向けのMCPサーバー構築計画を策定してほしい。
 TISのXenlonとの連携も視野に入れること。
 AIコーディングツールがNablarchの正確なコードを生成できるようにしたい。」
```

### 出力例（抜粋）

#### フレームワーク特性分析の例

```markdown
#### コアアーキテクチャ
- **処理モデル**: ハンドラキュー（パイプライン型、サーブレットフィルタチェーンと同様）
- **設定方式**: XMLベースのコンポーネント定義
- **特記事項**: ハンドラ間の順序制約あり、インターセプタによる動的ハンドラ追加

#### 独自の強み（MCP差別化ポイント）
1. ハンドラキューアーキテクチャの正確な理解（順序制約含む）
2. TIS開発標準・コーディング規約の組み込み
3. Excelベーステスト自動化との連携
4. Xenlon変換後コードへの最適化支援
```

#### Tools設計の例

```markdown
| ツール名 | 説明 | 入力 | 出力 |
|---|---|---|---|
| `generate_handler` | ハンドラキュー構成の生成 | アプリ種別、要件 | XMLハンドラキュー定義 |
| `validate_handler_queue` | ハンドラキュー構成の妥当性検証 | XML定義 | 検証結果、修正提案 |
| `search_api` | Nablarch API検索 | キーワード、カテゴリ | API情報一覧 |
| `analyze_migration` | Xenlon変換コードの分析 | Javaソースコード | 改善提案 |
```

#### Resources設計の例

```markdown
| リソースURI | 説明 |
|---|---|
| `nablarch://api/{module}/{class}` | API Javadocリファレンス |
| `nablarch://handler/{type}` | ハンドラ仕様（Web/Batch/REST等） |
| `nablarch://pattern/{name}` | 設計パターン・ベストプラクティス |
| `nablarch://config/{type}` | 標準ハンドラキュー構成テンプレート |
```

#### 技術スタック選定の例

```markdown
| コンポーネント | 選定 | 理由 |
|---|---|---|
| 言語 | Java 17+ | Nablarchとの一貫性、MCP Java SDK要件 |
| フレームワーク | Spring Boot 3.3+ | MCP Boot Starter活用 |
| MCP SDK | MCP Java SDK v0.17+ | 公式、Spring AI共同メンテナンス |
| トランスポート | STDIO + WebMVC | ローカル＆リモート両対応 |
```

### 別フレームワークへの適用例

#### Django向けの場合

```
入力: 「Django向けのMCPサーバーを設計したい。
       DRF（Django REST Framework）もカバーすること。」

→ STEP 2 で以下を分析:
  - コアアーキテクチャ: MTV (Model-Template-View) パターン
  - 設定方式: settings.py（Python設定ファイル）
  - 独自の強み: ORM、Admin自動生成、マイグレーションシステム
  - エコシステム: DRF、Celery、Django Channels

→ STEP 3 で以下を設計:
  - Tools: generate_model, generate_serializer, generate_view, validate_settings
  - Resources: django://api/{module}, django://pattern/{name}, django://settings/{key}
  - Prompts: create-django-app, create-drf-api, setup-celery

→ 技術スタック: Python (MCP Python SDK + FastMCP)
```

## Guidelines

### 必須ルール

1. **MCP仕様は必ず最新情報をWeb検索で確認すること**
   - プロトコルバージョン、SDK更新、新機能を毎回チェック
   - 古い情報に基づく設計は避ける

2. **対象FWの独自の強みを活かす設計にすること**
   - 汎用的なコード補完ではなく、FW固有の価値を提供する
   - 例: Nablarchならハンドラキュー、Djangoなら ORM/Admin、Railsなら Convention over Configuration

3. **既存エコシステムとの連携を考慮すること**
   - 移行ツール、IDE統合、CI/CDとの連携可能性を検討
   - 例: Nablarch + Xenlon、Rails + RuboCop

4. **段階的なロードマップを必ず含めること**
   - Phase 1（MVP）から始めて段階的に拡張
   - 各フェーズに明確な完了基準を設定

5. **リスク分析を必ず含めること**
   - 技術/ビジネス/セキュリティの3観点
   - 各リスクに対策を記載

### 注意事項

- レポートは対象フレームワークの言語圏に合わせて作成する（日本語指示なら日本語）
- Tools/Resources/Promptsは多すぎず少なすぎず、Phase 1で3〜5個を目安に開始
- 実装言語は原則として対象FWと同じ言語を選ぶ（SDK非対応の場合はTypeScript/Python）
- MCP Inspectorでのテスト手順を含めること
- 機密情報（社内ドキュメント、非公開API等）の取り扱いに注意し、OSSで公開可能な範囲を明確にする
- MCPサーバー自体のセキュリティ（プロンプトインジェクション対策等）を設計に含める
