---
name: mcp-prompt-generator
description: MCP Promptの設計・実装パターンをテンプレート化し、YAML知識ファイルに基づくPromptクラスとテストを自動生成する。「MCP Promptクラスを生成して」「新しいPromptテンプレートを作って」「SetupHandlerQueuePromptのようなPromptを追加して」「YAML知識からPromptを自動生成して」「McpServerConfigにPromptを登録するコードを生成して」「Promptの引数バリデーション付きクラスを作って」といった要望に対応する。McpSchema.GetPromptResult + McpSchema.PromptMessage パターンに基づくSpring Bean自動生成、引数バリデーション、Markdown応答構築、テストクラス生成、McpServerConfig統合を含む。
---

# MCP Prompt Generator — MCP Promptクラス自動生成

## Overview

MCP Promptの設計・実装パターンをテンプレート化し、YAML知識ファイルに基づくPromptクラスを自動生成するスキル。MCP仕様に準拠した`McpSchema.GetPromptResult`を返却するPromptクラス、対応するユニットテスト、McpServerConfig統合コードを一括生成する。

**参考実装（実績）:**
- `SetupHandlerQueuePrompt.java`（137行）: app_type引数 → ハンドラ一覧+順序制約+XMLテンプレートのMarkdown生成
- `CreateActionPrompt.java`: app_type + action_name引数 → アクションクラス生成ガイド
- `ReviewConfigPrompt.java`: config_xml引数 → XML設定レビューMarkdown
- `ExplainHandlerPrompt.java`: handler_name引数 → ハンドラ詳細説明
- `MigrationGuidePrompt.java`: from_version + to_version引数 → 移行ガイド
- `BestPracticesPrompt.java`: topic引数 → ベストプラクティスガイド
- `McpServerConfig.java`（216行）: 6 Prompt → SyncPromptSpecification登録

**主な用途:**
- 新しいMCP Promptの追加
- YAML知識ファイルに基づくPromptのMarkdown応答生成
- 引数バリデーション付きPromptクラスの実装
- テストクラスの自動生成
- McpServerConfigへの統合コード生成

**このスキルの特徴:**
- 6つの実装済みPromptパターンのテンプレート化
- 引数バリデーション（必須チェック、有効値チェック）の自動生成
- YAML読み込み → フィルタリング → Markdown構築の一気通貫パイプライン
- McpSchema.GetPromptResult の正しい構築パターン
- promptSpec() + arg() ヘルパーメソッドによるConfig統合

## When to Use

以下のいずれかに該当する場合にこのスキルを使用する：

- 「MCP Promptクラスを生成して」
- 「新しいPromptテンプレートを作って」
- 「SetupHandlerQueuePromptのようなPromptを追加して」
- 「YAML知識からPromptの応答を自動生成して」
- 「McpServerConfigにPromptを登録するコードを生成して」
- 「Promptの引数バリデーション付きクラスを作って」
- 「MCP Prompt仕様に準拠したクラスを実装して」
- MCP Promptとして知識ベースの情報を対話的に提供する必要がある場合
- 引数に応じて異なるMarkdown応答を生成するPromptが必要な場合

**トリガーキーワード**: MCP Prompt, Promptクラス, PromptMessage, GetPromptResult, Prompt生成, テンプレート生成, SyncPromptSpecification

## Input Format

```yaml
# 必須パラメータ
prompt_name: "setup-handler-queue"           # MCP Prompt名（kebab-case）
prompt_class_name: "SetupHandlerQueuePrompt" # 生成するクラス名（PascalCase）
description: "Set up a Nablarch handler queue configuration"  # Prompt説明

# 引数定義（1件以上）
arguments:
  - name: "app_type"                         # 引数名
    description: "Application type: web, rest, batch, messaging"  # 説明
    required: true                           # 必須フラグ
    valid_values:                            # 有効値リスト（任意）
      - "web"
      - "rest"
      - "batch"
      - "messaging"
  - name: "include_xml"                      # 2番目の引数（任意）
    description: "Include XML configuration template"
    required: false
    valid_values: null                        # 自由入力

# YAML知識ファイル
yaml_files:
  - path: "knowledge/handler-catalog.yaml"
    root_key: null                           # ルートキー（nullの場合Map全体）
    purpose: "ハンドラ一覧データの読み込み"
  - path: "knowledge/handler-constraints.yaml"
    root_key: "constraints"
    purpose: "順序制約データの読み込み"
  - path: "knowledge/config-templates.yaml"
    root_key: "templates"
    purpose: "XMLテンプレートデータの読み込み"

# Markdown応答の構成（セクション定義）
response_sections:
  - title: "概要"
    source: "yaml_files[0]"                  # データソース
    format: "paragraph"                      # paragraph | table | list | code
  - title: "推奨ハンドラキュー"
    source: "yaml_files[0].handlers"
    format: "table"
    columns: ["順序", "ハンドラ", "FQCN", "必須", "スレッド", "説明"]
  - title: "順序制約"
    source: "yaml_files[1]"
    format: "list"
  - title: "XML設定テンプレート"
    source: "yaml_files[2]"
    format: "code"
    language: "xml"

# 出力先
output_package: "com.tis.nablarch.mcp.prompts"
output_dir: "src/main/java/com/tis/nablarch/mcp/prompts"
test_dir: "src/test/java/com/tis/nablarch/mcp/prompts"
```

## Output Format

以下のファイルを生成する:

```
生成ファイル:
├── {output_dir}/{PromptClassName}.java          # Promptクラス本体
├── {test_dir}/{PromptClassName}Test.java        # ユニットテスト
└── McpServerConfig.java への追加コード片         # Config統合スニペット
```

## Instructions

### Phase 1: Prompt設計

#### Step 1.1: 引数仕様の確定

```
【確認事項】

1. 引数の型と制約:
   - 全引数はString型（MCP Promptの引数はMap<String, String>）
   - required=true の引数は null/blank チェック必須
   - valid_values がある引数は値チェック必須

2. 引数バリデーション戦略:
   - 必須チェック: argument == null || argument.isBlank()
   - 値チェック: !VALID_VALUES.contains(argument)
   - エラー: IllegalArgumentException を投げる
   - エラーメッセージ: 「{arg_name} は必須です。指定可能な値: [...]」

3. バリデーション順序:
   a. 必須引数のnull/blankチェック
   b. 有効値リストがある場合の値チェック
   c. 全チェック通過後にMarkdown生成開始
```

#### Step 1.2: Markdown応答構造の設計

```
【応答テンプレート設計】

Promptの応答は以下の構造に従う:

# {prompt_name} — {主要引数の値}

## {section_1.title}
{YAML知識データに基づく内容}

## {section_2.title}
{テーブル or リスト or コードブロック}

...

---
*Generated by {prompt_name} prompt*

【セクション構築パターン】

■ format: "paragraph"
  → sb.append(data.get("description")).append("\n\n");

■ format: "table"
  → sb.append("| Col1 | Col2 | ... |\n");
     sb.append("|------|------|-----|\n");
     for (var row : dataList) { ... }

■ format: "list"
  → for (var item : dataList) {
         sb.append("### ").append(item.get("name")).append("\n");
         sb.append("- **Key**: ").append(item.get("value")).append("\n");
     }

■ format: "code"
  → sb.append("```").append(language).append("\n");
     sb.append(data.get("template")).append("```\n");
```

### Phase 2: Promptクラスの生成

#### Step 2.1: クラス本体の生成

```
【生成テンプレート】

package {output_package};

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;
import io.modelcontextprotocol.spec.McpSchema;
import jakarta.annotation.PostConstruct;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;

/**
 * {prompt_name} Promptの実装。
 *
 * <p>{description}。
 * {yaml_files のパスリスト} から知識を読み込み、
 * Markdown形式のガイドを出力する。</p>
 */
@Component
public class {PromptClassName} {

    private static final ObjectMapper YAML = new ObjectMapper(new YAMLFactory());
    {valid_values がある場合: private static final List<String> VALID_{ARG}_VALUES = List.of(...);}

    {YAMLデータフィールド定義}

    /**
     * 知識YAMLファイルを読み込んで初期化する。
     */
    @PostConstruct
    @SuppressWarnings("unchecked")
    void init() throws IOException {
        {yaml_files ごとの読み込みコード}
    }

    /**
     * Promptを実行してMarkdownガイドを生成する。
     *
     * @param arguments MCP Promptの引数マップ
     * @return Markdown応答を含むPrompt結果
     * @throws IllegalArgumentException 必須引数が未指定または不正な場合
     */
    @SuppressWarnings("unchecked")
    public McpSchema.GetPromptResult execute(Map<String, String> arguments) {
        // 引数バリデーション
        {arguments ごとのバリデーションコード}

        // Markdown構築
        var sb = new StringBuilder();
        sb.append("# {prompt応答タイトル}\n\n");

        {response_sections ごとのMarkdown構築コード}

        // GetPromptResult構築
        return new McpSchema.GetPromptResult(
            "{prompt応答の説明}",
            List.of(new McpSchema.PromptMessage(
                McpSchema.Role.USER,
                new McpSchema.TextContent(sb.toString())
            ))
        );
    }
}

【重要な実装パターン】

1. 引数バリデーション:
   String appType = arguments != null ? arguments.get("app_type") : null;
   if (appType == null || appType.isBlank()) {
       throw new IllegalArgumentException(
           "app_type は必須です。指定可能な値: " + VALID_APP_TYPE_VALUES);
   }
   if (!VALID_APP_TYPE_VALUES.contains(appType)) {
       throw new IllegalArgumentException(
           "不正な app_type: " + appType + "。指定可能な値: " + VALID_APP_TYPE_VALUES);
   }

2. YAML読み込み（@PostConstruct内）:
   try (InputStream is = getClass().getResourceAsStream("/knowledge/{file}.yaml")) {
       {fieldName} = YAML.readValue(is, Map.class);
   }

3. GetPromptResult構築:
   return new McpSchema.GetPromptResult(
       "{説明文}",
       List.of(new McpSchema.PromptMessage(
           McpSchema.Role.USER,
           new McpSchema.TextContent(sb.toString())
       ))
   );
   ※ Role.USER を使用（Promptはユーザーメッセージとして挿入される）
```

### Phase 3: テストクラスの生成

#### Step 3.1: ユニットテストの生成

```
【テストテンプレート】

package {output_package};

import io.modelcontextprotocol.spec.McpSchema;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

class {PromptClassName}Test {

    private {PromptClassName} prompt;

    @BeforeEach
    void setUp() throws Exception {
        prompt = new {PromptClassName}();
        prompt.init();
    }

    {required引数ごとのバリデーションテスト}

    {valid_values がある引数ごとの値チェックテスト}

    {正常系テスト: 全valid_valuesの組み合わせ}

    {レスポンス内容テスト: セクション存在確認}
}

【テストパターン】

■ 必須引数のnullテスト:
@Test
void execute_nullAppType_throwsException() {
    assertThatThrownBy(() -> prompt.execute(Map.of()))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("app_type");
}

■ 必須引数のblankテスト:
@Test
void execute_blankAppType_throwsException() {
    assertThatThrownBy(() -> prompt.execute(Map.of("app_type", "")))
            .isInstanceOf(IllegalArgumentException.class);
}

■ 不正値テスト:
@Test
void execute_invalidAppType_throwsException() {
    assertThatThrownBy(() -> prompt.execute(Map.of("app_type", "invalid")))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("不正な");
}

■ 正常系テスト（ParameterizedTest）:
@ParameterizedTest
@ValueSource(strings = {"web", "rest", "batch", "messaging"})
void execute_validAppType_returnsResult(String appType) {
    McpSchema.GetPromptResult result = prompt.execute(Map.of("app_type", appType));

    assertThat(result).isNotNull();
    assertThat(result.messages()).isNotEmpty();
    assertThat(result.messages().get(0).content())
            .isInstanceOf(McpSchema.TextContent.class);

    String text = ((McpSchema.TextContent) result.messages().get(0).content()).text();
    assertThat(text).contains("#");      // Markdown見出しあり
    assertThat(text).contains(appType);  // 引数値が含まれる
}

■ セクション存在テスト:
@Test
void execute_web_containsExpectedSections() {
    McpSchema.GetPromptResult result = prompt.execute(Map.of("app_type", "web"));
    String text = ((McpSchema.TextContent) result.messages().get(0).content()).text();

    assertThat(text).contains("概要");
    assertThat(text).contains("推奨ハンドラキュー");
    assertThat(text).contains("順序制約");
}
```

### Phase 4: McpServerConfig統合コードの生成

#### Step 4.1: Config登録スニペットの生成

```
【SyncPromptSpecification 登録パターン】

McpServerConfig.java に以下を追加する。

1. nablarchPrompts() メソッドの引数に追加:
   {PromptClassName} {promptVarName}

2. promptSpec() 呼び出しを追加:
   promptSpec("{prompt_name}",
       "{description}",
       List.of(
           {arguments ごとの arg() 呼び出し}
       ),
       {promptVarName}::execute)

3. arg() の形式:
   arg("{arg_name}", "{arg_description}", {required})

【実例（SetupHandlerQueuePromptの場合）】

promptSpec("setup-handler-queue",
    "Set up a Nablarch handler queue configuration",
    List.of(arg("app_type", "Application type: web, rest, batch, messaging", true)),
    setupHandlerQueuePrompt::execute)
```

### Phase 5: 品質検証

```
□ Promptクラスチェック
  □ @Component アノテーション
  □ @PostConstruct でYAML初期化
  □ execute()メソッドのシグネチャ: Map<String, String> → McpSchema.GetPromptResult
  □ 必須引数のnull/blankバリデーション
  □ valid_values がある引数の値バリデーション
  □ IllegalArgumentException のメッセージに有効値一覧を含む
  □ McpSchema.Role.USER を使用
  □ sb.toString() をTextContentに渡している

□ テストチェック
  □ @BeforeEach で init() を呼び出している
  □ 全必須引数のnull/blankテスト
  □ 全valid_valuesのParameterizedTest
  □ 不正値テスト
  □ レスポンス構造テスト（messages非空、TextContent型）
  □ Markdownセクション存在テスト

□ Config統合チェック
  □ promptSpec() の引数が正しい
  □ arg() のrequiredフラグが正しい
  □ メソッド参照（::execute）が正しい
```

## Examples

### Example 1: SetupHandlerQueuePrompt（既存実装の再現）

```yaml
prompt_name: "setup-handler-queue"
prompt_class_name: "SetupHandlerQueuePrompt"
description: "Set up a Nablarch handler queue configuration"
arguments:
  - name: "app_type"
    description: "Application type: web, rest, batch, messaging"
    required: true
    valid_values: ["web", "rest", "batch", "messaging"]
yaml_files:
  - { path: "knowledge/handler-catalog.yaml", root_key: null }
  - { path: "knowledge/handler-constraints.yaml", root_key: "constraints" }
  - { path: "knowledge/config-templates.yaml", root_key: "templates" }
response_sections:
  - { title: "概要", format: "paragraph" }
  - { title: "推奨ハンドラキュー", format: "table" }
  - { title: "順序制約", format: "list" }
  - { title: "XML設定テンプレート", format: "code", language: "xml" }
```

### Example 2: 新規Prompt（TroubleshootPrompt）

```yaml
prompt_name: "troubleshoot"
prompt_class_name: "TroubleshootPrompt"
description: "Troubleshoot a Nablarch error"
arguments:
  - name: "error_message"
    description: "Error message or stack trace"
    required: true
    valid_values: null
  - name: "category"
    description: "Error category: configuration, runtime, handler, database"
    required: false
    valid_values: ["configuration", "runtime", "handler", "database"]
yaml_files:
  - { path: "knowledge/error-catalog.yaml", root_key: "errors" }
response_sections:
  - { title: "エラー分析", format: "paragraph" }
  - { title: "一致するエラーパターン", format: "table" }
  - { title: "解決策", format: "list" }
```

## Anti-Patterns

1. **McpSchema.Role の間違い**
   - NG: `McpSchema.Role.ASSISTANT`
   - OK: `McpSchema.Role.USER`（Promptはユーザーメッセージとして挿入）
   - MCP仕様: Prompt結果はユーザーのコンテキストに挿入される

2. **引数バリデーションの漏れ**
   - required=trueの引数にnullチェックがない → NullPointerException
   - 対策: 全required引数のnull/blankチェックを自動生成

3. **arguments が null の場合の未処理**
   - `arguments.get("key")` でNPE
   - 対策: `arguments != null ? arguments.get("key") : null` パターン必須

4. **GetPromptResult の description 省略**
   - descriptionはnull許容だが、空だとAIクライアントが困る
   - 対策: 常に意味のある説明文を設定

5. **YAML読み込みパスの不一致**
   - `/knowledge/` （先頭スラッシュあり）vs `knowledge/`（なし）
   - SetupHandlerQueuePromptは `/knowledge/` を使用（getResourceAsStream）
   - HandlerResourceProviderは `knowledge/` を使用（getClassLoader().getResourceAsStream）
   - 対策: プロジェクト内の統一パターンに合わせる

6. **テストでのYAMLデータ依存**
   - テストがsrc/main/resources/knowledge/ のYAMLに依存
   - YAMLの構造変更でテストが壊れる
   - 対策: テスト用のYAMLデータを用意するか、依存を許容してドキュメント化

7. **Markdown内の改行不足**
   - `\n` が足りずMarkdownのレンダリングが崩れる
   - 対策: セクション間は `\n\n` を必ず入れる

8. **テーブルヘッダーとデータの列数不一致**
   - ヘッダー6列なのにデータ5列 → テーブル崩壊
   - 対策: append時にカラム数を揃えるヘルパーメソッドを使用
